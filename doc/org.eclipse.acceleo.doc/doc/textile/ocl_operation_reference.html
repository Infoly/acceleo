<?xml version='1.0' encoding='utf-8' ?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/></head><body><h1 id="OCL_operation_reference">OCL operation reference</h1><h2 id="Ocl_operations_for_type_*Classifier*">Ocl operations for type *Classifier*</h2><h3 id="allInstances_.28.29_:_Set.7BT.7D">allInstances () : Set{T}</h3><p>Returns a Set containing all of the existing instances of the current classifier (along with instances of all its inherited classifiers).</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let a : String = 'a', b : String = 'b', c : Integer = 2 in String.allInstances()</td><td>Set{'a','b'}</td></tr></table><h2 id="Ocl_operations_for_type_*OclAny*">Ocl operations for type *OclAny*</h2><h3 id="oclAsType_.28_typespec_:_Classifier_.29_:_T">oclAsType ( typespec : Classifier ) : T</h3><p>Returns *self* statically typed as typespec if it is an instance of this type. *Note* that this does not alter the runtime value of *self*, it only enables access to subtype operations. This operation allows users to cast <b>self</b> to another type.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>aPerson.oclAsType(Employee) </td><td>an object of Employee type</td></tr></table><h3 id="oclIsInvalid_.28.29_:_Boolean">oclIsInvalid () : Boolean</h3><p>Returns <b>true</b> if <b>self</b> is equal to *invalid*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let anObject : String = null in anObject.oclIsUndefined()</td><td>false</td></tr><tr><td>let anObject : String = invalid in anObject.oclIsUndefined()</td><td>true</td></tr><tr><td>let anObject : String = 'null' in anObject.oclIsUndefined()</td><td>false</td></tr></table><h3 id="oclIsKindOf.28_Classifier_typespec_.29_:_Boolean">oclIsKindOf( Classifier typespec ) : Boolean</h3><p>Returns **true** if the type of <b>self</b> corresponds to the type or supertype of typespec, <b>false</b> otherwise. This operation allows users to check the class hierarchy of <b>self</b> much like would an <b>instanceof</b> Java.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>anEmployee.oclIsKindOf(Employee)</td><td>true</td></tr><tr><td>anEmployee.oclIsKindOf(Person)</td><td>true</td></tr><tr><td>aCat.oclIsKindOf(Person)</td><td>false</td></tr></table><h3 id="oclIsTypeOf.28_typespec_:_Classifier_.29_:_Boolean">oclIsTypeOf( typespec : Classifier ) : Boolean</h3><p>Returns <b>true</b> if the type of <b>self</b> is the same as typespec, or **false** otherwise. This operation allows users to check the exact class type of <b>self</b>.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>anEmployee.oclIsTypeOf(Employee)</td><td>true</td></tr><tr><td>anEmployee.oclIsTypeOf(Person)</td><td>false</td></tr><tr><td>aCat.oclIsTypeOf(Person)</td><td>false</td></tr></table><h3 id="oclIsUndefined_.28.29_:_Boolean">oclIsUndefined () : Boolean</h3><p>Returns **true** if *self* is equal to *invalid* or *null*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let anObject : String = null in anObject.oclIsUndefined()</td><td>true</td></tr><tr><td>let anObject : String = invalid in anObject.oclIsUndefined()</td><td>true</td></tr><tr><td>let anObject : String = 'null' in anObject.oclIsUndefined()</td><td>false</td></tr></table><h3 id=".3C.3E_.28_object_:_OclAny_.29_:_Boolean">&lt;&gt; ( object : OclAny ) : Boolean</h3><p>Returns **true** if *self* is a different object from *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let a : String = 'a', b : String = 'a' in a &lt;&gt; b</td><td>false</td></tr><tr><td>let a : Integer = 2, b : Real = 2.0 in a &lt;&gt; b</td><td>false</td></tr><tr><td>let a : Integer = -2, b : Integer = 2 in a &lt;&gt; b</td><td>true</td></tr></table><h3 id=".3D_.28_object_:_OclAny.29_:_Boolean">= ( object : OclAny) : Boolean</h3><p>Returns **true** if *self* is equal to *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let a : String = 'a', b : String = 'a' in a = b</td><td>true</td></tr><tr><td>let a : Integer = 2, b : Real = 2.0 in a = b</td><td>true</td></tr><tr><td>let a : Integer = -2, b : Integer = 2 in a = b</td><td>false</td></tr></table><h3 id=".3C_.28_object_:_T_.29_:_Boolean">&lt; ( object : T ) : Boolean</h3><p>Returns **true** if *self* is comparable to *object* and less than *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let a : Integer = 1, b : Integer = 2 in a &lt; b</td><td>true</td></tr><tr><td>let a : Real = 1.5, b : Integer = 2 in a &lt; b</td><td>true</td></tr><tr><td>let a : String = 'Anteater', b : String = 'Aardvark' in a &lt; b</td><td>false</td></tr></table><h3 id=".3E_.28_object_:_T_.29_:_Boolean">&gt; ( object : T ) : Boolean</h3><p>Returns **true** if *self* is comparable to *object* and greater than *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let a : Integer = 1, b : Integer = 2 in a &gt; b</td><td>false</td></tr><tr><td>let a : Real = 1.5, b : Integer = 2 in a &gt; b</td><td>false</td></tr><tr><td>let a : String = 'Anteater', b : String = 'Aardvark' in a &gt; b</td><td>true</td></tr></table><h3 id=".3C.3D_.28_object_:_T_.29_:_Boolean">&lt;= ( object : T ) : Boolean</h3><p>Returns **true** if *self* is comparable to *object* and less than or equal to *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let a : Integer = 1, b : Integer = 2 in a &lt;= b</td><td>true</td></tr><tr><td>let a : Real = 1.5, b : Integer = 2 in a &lt;= b</td><td>true</td></tr><tr><td>let a : String = 'Anteater', b : String = 'Aardvark' in a &lt;= b</td><td>false</td></tr></table><h3 id=".3E.3D_.28_object_:_T_.29_:_Boolean">&gt;= ( object : T ) : Boolean</h3><p>Returns **true** if *self* is comparable to *object* and greater than or equal to *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>let a : Integer = 1, b : Integer = 2 in a &gt;= b</td><td>false</td></tr><tr><td>let a : Real = 1.5, b : Integer = 2 in a &gt;= b</td><td>false</td></tr><tr><td>let a : String = 'Anteater', b : String = 'Aardvark' in a &gt;= b</td><td>true</td></tr></table><h2 id="Ocl_operations_for_type_*String*">Ocl operations for type *String*</h2><ul><li><ul><li>A note on Strings** : OCL Strings begin at index *1*, not *0* as in most languages. Thus *'test'.at(0)* fails in</li></ul></li><li>invalid* whereas *'test'.at(1)* yields *'t'*. Likewise, *'test'.substring(2, 2)* returns *'e'*.</li></ul><h3 id="concat_.28_s_:_String_.29_:_String">concat ( s : String ) : String</h3><p>Returns a string containing *self* followed by *s*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>'concat'.concat(' ').concat('operation')</td><td>'concat operation'</td></tr></table><h3 id="size_.28.29_:_Integer">size () : Integer</h3><p>Returns the number of characters composing *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>'size operation'.size()</td><td>14</td></tr></table><h3 id="substring_.28_lower_:_Integer.2C_upper_:_Integer_.29_:_String">substring ( lower : Integer, upper : Integer ) : String</h3><p>Returns a string containing all characters from *self* starting from index *lower* up to index *upper* included. Both *lower* and *upper* parameters should be contained between *1* and *self.size()* included. *lower* cannot be greater than *upper*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>'substring operation'.substring(11, 19)</td><td>'operation'</td></tr><tr><td>'substring operation'.substring(1, 1)</td><td>'s'</td></tr><tr><td>'substring operation'.substring(0, 1)</td><td><b><i>invalid</i></b></td></tr></table><h3 id="toInteger_.28.29_:_Integer">toInteger () : Integer</h3><p>Returns an Integer of value equal to *self*, or |invalid| if *self* does not represent an integer.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>'3.0'.toInteger()</td><td><b><i>invalid</i></b></td></tr><tr><td>'4'.toInteger()</td><td>4</td></tr><tr><td>'toInteger'.toInteger()</td><td><b><i>invalid</i></b></td></tr></table><h3 id="toLower_.28.29_:_String">toLower () : String</h3><p>Returns *self* with all characters converted to lowercase.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>'LoWeR OpErAtIoN'.toLower()</td><td>'lower operation'</td></tr></table><h3 id="toReal_.28.29_:_Real">toReal () : Real</h3><p>Returns a Real of value equal to *self*, or |invalid| if *self* does not represent a real.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>'3.0'.toReal()</td><td>3.0</td></tr><tr><td>'4'.toReal()</td><td>4.0</td></tr><tr><td>'toReal'.toReal()</td><td><b><i>invalid</i></b></td></tr></table><h3 id="toUpper_.28.29_:_String">toUpper () : String</h3><p>Returns *self* with all characters converted to uppercase.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>'UpPeR OpErAtIoN'.toUpper()</td><td>'UPPER OPERATION'</td></tr></table><h2 id="Ocl_operations_for_type_*Number*">Ocl operations for type *Number*</h2><p>In addition to the basic math functions (+, -, /, \*) are a number of advanced functions. Take note that *Number* denotes both *Integer* and *Real*, and they're substitutive unless otherwise specified.</p><h3 id="Number::abs_.28.29_:_Number">Number::abs () : Number</h3><p>Returns the absolute value of *self*, *self* if it is already a positive number.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>(-2.3).abs()</td><td>2.3</td></tr><tr><td>-5.abs()</td><td>5</td></tr></table><h3 id="Number::floor_.28.29_:_Integer">Number::floor () : Integer</h3><p>Returns the integer part of *self* if it is a Real, *self* if it is an Integer.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>(2.3).floor()</td><td>2</td></tr><tr><td>(2.8).floor()</td><td>2</td></tr><tr><td>2.floor()</td><td>2</td></tr></table><h3 id="Number::max_.28_r_:_Number_.29_:_Number">Number::max ( r : Number ) : Number</h3><p>Returns the greatest number between *self* and *r*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>6.max(3)</td><td>6</td></tr><tr><td>6.max(5.2)</td><td>6.0</td></tr><tr><td>(2.3).max(3)</td><td>3.0</td></tr><tr><td>(2.3).max(5.2)</td><td>5.2</td></tr></table><h3 id="Number::min_.28_r_:_Number_.29_:_Number">Number::min ( r : Number ) : Number</h3><p>Returns the lowest number between *self* and *r*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>6.min(3)</td><td>3</td></tr><tr><td>6.min(5.2)</td><td>5.2</td></tr><tr><td>(2.3).min(3)</td><td>2.3</td></tr><tr><td>(2.3).min(5.2)</td><td>2.3</td></tr></table><h3 id="Number::round_.28.29_:_Integer">Number::round () : Integer</h3><p>Returns the nearest integer to *self* if it is a Real, *self* if it is an Integer.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>(2.3).round()</td><td>2</td></tr><tr><td>(2.5).round()</td><td>3</td></tr><tr><td>(2.8).round()</td><td>3</td></tr><tr><td>2.round()</td><td>2</td></tr></table><h3 id="Integer::div_.28_i_:_Integer_.29_:_Integer">Integer::div ( i : Integer ) : Integer</h3><p>Returns the integer quotient of the division of *self* by *i*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>3.div(2)</td><td>1</td></tr><tr><td>11.div(3)</td><td>3</td></tr></table><h3 id="Integer::mod_.28_i_:_Integer_.29_:_Integer">Integer::mod ( i : Integer ) : Integer</h3><p>Returns the integer remainder of the division of *self* by *i*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>3.mod(2)</td><td>1</td></tr><tr><td>11.mod(3)</td><td>2</td></tr></table><h2 id="Ocl_operations_for_type_*Collection*">Ocl operations for type *Collection*</h2><p>Please note that OCL collections can contain the *null* value (null) but not the *invalid* value (|invalid|). Trying to add |invalid| within a new or existing collection will yield |invalid| as a result. OCL proposes four distinct kinds of collections offering all possibilities of ordering/unicity.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Collection type</th><th style="background: #BCBCBC;" align="center">Ordered</th><th style="background: #BCBCBC;" align="center">Unique</th></tr><tr><td>Sequence</td><td>true</td><td>false</td></tr><tr><td>OrderedSet</td><td>true</td><td>true</td></tr><tr><td>Bag</td><td>false</td><td>false</td></tr><tr><td>Set</td><td>false</td><td>true</td></tr><tr></tr></table><h3 id="any_.28_expr_:_OclExpression_.29_:_T">any ( expr : OclExpression ) : T</h3><p>Returns any element contained in *self* that validates the condition *expr*, null otherwise. Evaluation is shortcut as soon as an element validating *expr* is found. Note that the result of this on unordered collections will be random if more than one element validates *expr*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{1.2, 2.3, 5.2, 0.9}-&gt;any(self &lt; 1)</td><td>0.9</td></tr><tr><td>Sequence{1.2, 2.3, 5.2, 0.9}-&gt;any(self &lt; 2)</td><td>1.2</td></tr></table><h3 id="asBag_.28.29_:_Bag.28T.29">asBag () : Bag(T)</h3><p>Returns a Bag containing all elements of *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'3', 1, 2.0, '3'}-&gt;asBag()</td><td>Bag{2.0, '3', 1, '3'}</td></tr><tr><td>Bag{1, 2.0, '3'}-&gt;asBag()</td><td>Bag{2.0, 1, '3'}</td></tr><tr><td>OrderedSet{1, 2.0, '3'}-&gt;asBag()</td><td>Bag{2.0, 1, '3'}</td></tr><tr><td>OrderedSet{1, 1, 2.0, '3'}-&gt;asBag()</td><td>Bag{'3', 1, 2.0}</td></tr><tr><td>Set{1, 2.0, '3'}-&gt;asBag()</td><td>Bag{2.0, 1, '3'}</td></tr><tr><td>Set{1, 1, 2.0, '3'}-&gt;asBag()</td><td>Bag{2.0, '3', 1}</td></tr></table><h3 id="asOrderedSet_.28.29_:_OrderedSet.28T.29">asOrderedSet () : OrderedSet(T)</h3><p>Returns an OrderedSet containing all elements of *self*. Element ordering is preserved when possible.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{1, 2.0, '3'}-&gt;asOrderedSet()</td><td>OrderedSet{1, '3', 2.0}</td></tr><tr><td>Sequence{1, 1, 2.0, '3'}-&gt;asOrderedSet()</td><td>OrderedSet{'3', 1, 2.0}</td></tr><tr><td>Bag{1, 2.0, '3'}-&gt;asOrderedSet()</td><td>OrderedSet{2.0, 1, '3'}</td></tr><tr><td>Bag{1, 1, 2.0, '3'}-&gt;asOrderedSet()</td><td>OrderedSet{1, '3', 2.0}</td></tr><tr><td>OrderedSet{1, 2.0, '3'}-&gt;asOrderedSet()</td><td>OrderedSet{1, 2.0, '3'}</td></tr><tr><td>Set{1, 2.0, '3'}-&gt;asOrderedSet()</td><td>OrderedSet{'3', 1, 2.0}</td></tr></table><h3 id="asSequence_.28.29_:_Boolean">asSequence () : Boolean</h3><p>Returns a Sequence containing all elements of *self*. Element ordering is preserved when possible.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{1, 2.0, '3'}-&gt;asSequence()</td><td>Sequence{1, 2.0, '3'}</td></tr><tr><td>Bag{1, 2.0, '3'}-&gt;asSequence()</td><td>Sequence{2.0, 1, '3'}</td></tr><tr><td>OrderedSet{1, 2.0, '3'}-&gt;asSequence()</td><td>Sequence{1, 2.0, '3'}</td></tr><tr><td>Set{1, 2.0, '3'}-&gt;asSequence()</td><td>Sequence{'3', 1, 2.0}</td></tr></table><h3 id="asSet_.28.29_:_Set.28T.29">asSet () : Set(T)</h3><p>Returns a Set containing all elements of *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{1, 2.0, '3'}-&gt;asSet()</td><td>Set{1, '3', 2.0}</td></tr><tr><td>Sequence{1, 1, 2.0, '3'}-&gt;asSet()</td><td>Set{'3', 1, 2.0}</td></tr><tr><td>Bag{1, 2.0, '3'}-&gt;asSet()</td><td>Set{2.0, 1, '3'}</td></tr><tr><td>Bag{1, 1, 2.0, '3'}-&gt;asSet()</td><td>Set{1, '3', 2.0}</td></tr><tr><td>OrderedSet{1, 2.0, '3'}-&gt;asSet()</td><td>Set{1, '3', 2.0}</td></tr><tr><td>OrderedSet{1, 1, 2.0, '3'}-&gt;asSet()</td><td>Set{'3', 1, 2.0}</td></tr><tr><td>Set{1, 2.0, '3'}-&gt;asSet()</td><td>Set{2.0, 1, '3'}</td></tr><tr><td>Set{1, 1, 2.0, '3'}-&gt;asSet()</td><td>Set{'3', 1, 2.0}</td></tr></table><h3 id="collect_.28_expr_:_OclExpression_.29_:_Collection.28T2.29">collect ( expr : OclExpression ) : Collection(T2)</h3><p>Returns a collection containing the result of applying *expr* on all elements contained in *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'first', 'second'}-&gt;collect(toUpper())</td><td>Sequence{'FIRST', 'SECOND'}</td></tr></table><h3 id="collectNested_.28_expr_:_OclExpression_.29_:_Collection.28T2.29">collectNested ( expr : OclExpression ) : Collection(T2)</h3><p>Returns a collection containing all the elements contained in *self* on which we applied the OclExpression *expr*. The results won't be flattened. The type of the resulting collection depends on the type of *self*.</p><p>For the purpose of these examples we'll assume here that we have a Class *Person* with a reference *children*. Our model contains two persons such as *person1.children = {James, Jane}* and *person2.children = {John}*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>self.persons-&gt;collectNested(children.firstname)</td><td>Sequence{Sequence{James, Jane}, Sequence{John}}</td></tr></table><h3 id="count_.28_object_:_T_.29_:_Integer">count ( object : T ) : Integer</h3><p>Returns how many times *object* is in the collection *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5.2}-&gt;count(5.2)</td><td>1</td></tr><tr><td>Set{3, 'test', 4.0, 4, 4.0, 'test'}-&gt;count(null)</td><td>0</td></tr><tr><td>Set{3, null, 4.0, null, 'test'}-&gt;count(null)</td><td>1</td></tr><tr><td>Bag{3, null, 4.0, null, 'test'}-&gt;count(null)</td><td>2</td></tr></table><h3 id="excludes_.28_object_:_T_.29_:_Boolean">excludes ( object : T ) : Boolean</h3><p>Returns **true** if *object* is not contained in *self*, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3}-&gt;excludes(2.1)</td><td>true</td></tr><tr><td>Sequence{2.0}-&gt;excludes(2)</td><td>false</td></tr></table><h3 id="excludesAll_.28_c2_:_Collection.28T.29_.29_:_Boolean">excludesAll ( c2 : Collection(T) ) : Boolean</h3><p>Returns **true** if no element of *c2* is contained in *self*, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5.2, 'a', 3, null}-&gt;excludesAll(Set{4, null})</td><td>false</td></tr><tr><td>Sequence{2.3, 5.2, 'a', 3}-&gt;excludesAll(Set{4, null})</td><td>true</td></tr></table><h3 id="excluding_.28_object_:_T_.29_:_Collection.28T.29">excluding ( object : T ) : Collection(T)</h3><p>Returns a collection containing all elements of *self* minus all occurences of *object*. **Note** : at the time of writing, the OCL standard library sports a bug which changes *OrderedSets* in *Sets* when excluding elements.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'b', 'a', 'b', 'c'}-&gt;excluding('b')</td><td>Sequence{'a', 'c'}</td></tr><tr><td>Bag{'b', 'a', 'b', 'c'}-&gt;excluding('b')</td><td>Bag{'c', 'a'}</td></tr><tr><td>OrderedSet{'b', 'a', 'b', 'c'}-&gt;excluding('b')</td><td>Set{'c', 'a'}</td></tr><tr><td>Set{'b', 'a', 'b', 'c'}-&gt;excluding('b')</td><td>Set{'c', 'a'}</td></tr></table><h3 id="exists_.28_expr_:_OclExpression_.29_:_Boolean">exists ( expr : OclExpression ) : Boolean</h3><p>Returns **true** if at least one element in *self* validates the condition *expr*, **false** otherwise. The evaluation stops as soon as one element validating *expr* is found.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5.2}-&gt;exists(self &gt; 3)</td><td>true</td></tr></table><h3 id="flatten_.28.29_:_Collection.28T2.29">flatten () : Collection(T2)</h3><p>Returns a collection containing all elements of *self* recursively flattened. **Note** : at the time of writing, the OCL standard library sports a bug which changes *OrderedSets* in *Sets* when flattening. </p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{Set{1, 2, 3}, Sequence{2.0, 3.0}, Bag{'test'}}-&gt;flatten()</td><td>Sequence{1, 2, 3, 2.0, 3.0, 'test'}</td></tr><tr><td>Bag{Set{Bag{'test', 2, 3.0}}, Sequence{OrderedSet{2.0, 3, 1}}}-&gt;flatten()</td><td>Bag{1, 2, 3, 2.0, 3.0, 'test'}</td></tr><tr><td>OrderedSet{Set{Bag{'test', 2, 3.0}}, Sequence{Set{2.0, 3, 1}}}-&gt;flatten()</td><td>Set{3.0, 2, 1, 3, 'test', 2.0}</td></tr><tr><td>Set{Set{Bag{'test', 2, 3.0}}, Sequence{OrderedSet{2.0, 3, 1}}}-&gt;flatten()</td><td>Set{3.0, 2, 1, 3, 'test', 2.0}</td></tr></table><h3 id="forAll_.28_expr_:_OclExpression_.29_:_Boolean">forAll ( expr : OclExpression ) : Boolean</h3><p>Returns **true** if the all the elements contained in *self* validate the condition *expr*, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5.2}-&gt;forAll(self &gt; 3)</td><td>false</td></tr><tr><td>Sequence{2.3, 5.2}-&gt;forAll(self &gt; 1.2)</td><td>true</td></tr></table><h3 id="includes_.28_object_:_T_.29_:_Boolean">includes ( object : T ) : Boolean</h3><p>Returns **true** if *object* is contained in *self*, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3}-&gt;includes(2.1)</td><td>false</td></tr><tr><td>Sequence{2.0}-&gt;includes(2)</td><td>true</td></tr></table><h3 id="includesAll_.28_c2_:_Collection.28T.29_.29_:_Boolean">includesAll ( c2 : Collection(T) ) : Boolean</h3><p>Returns **true** if all element of *c2* are contained in *self*, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5.2, 'a', 3, null}-&gt;includesAll(Set{3, null})</td><td>true</td></tr><tr><td>Sequence{2.3, 5.2, 'a', 3}-&gt;includesAll(Set{3, null})</td><td>false</td></tr></table><h3 id="including_.28_object_:_T_.29_:_Collection.28T.29">including ( object : T ) : Collection(T)</h3><p>Returns a collection containing all elements of *self* followed by *object*. **Note** : at the time of writing, the OCL standard library sports a bug which changes *OrderedSets* in *Sets* when including elements.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b'}-&gt;including('c')</td><td>Sequence{'a', 'b', 'c'}</td></tr><tr><td>Bag{'a', 'b'}-&gt;including('c')</td><td>Bag{'a', 'c', 'b'}</td></tr><tr><td>OrderedSet{'a', 'b'}-&gt;including('c')</td><td>Set{'a', 'c', 'b'}</td></tr><tr><td>Set{'a', 'b'}-&gt;including('c')</td><td>Set{'a', 'c', 'b'}</td></tr></table><h3 id="isEmpty_.28.29_:_Boolean">isEmpty () : Boolean</h3><p>Returns **true** if *self* is empty, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2, 'a'}-&gt;isEmpty()</td><td>false</td></tr><tr><td>Sequence{null}-&gt;isEmpty()</td><td>false</td></tr><tr><td>Sequence{}-&gt;isEmpty()</td><td>true</td></tr></table><h3 id="isUnique_.28_expr_:_OclExpression_.29_:_Boolean">isUnique ( expr : OclExpression ) : Boolean</h3><p>Returns **true** if all elements contained in *self* evaluate to a distinct value for *expr*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5.2}-&gt;isUnique(self &gt; 3)</td><td>true</td></tr><tr><td>Sequence{2.3, 5.2}-&gt;isUnique(self &gt; 1)</td><td>false</td></tr></table><h3 id="notEmpty_.28.29_:_Boolean">notEmpty () : Boolean</h3><p>Returns **true** if *self* contains at least one element, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2, 'a'}-&gt;notEmpty()</td><td>true</td></tr><tr><td>Sequence{null}-&gt;notEmpty()</td><td>true</td></tr><tr><td>Sequence{}-&gt;notEmpty()</td><td>false</td></tr></table><h3 id="one_.28_expr_:_OclExpression_.29_:_Boolean">one ( expr : OclExpression ) : Boolean</h3><p>Returns **true** if there is only one element contained in *self* that validates the condition *expr*, **false** otherwise.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{1.2, 2.3, 5.2, 0.9}-&gt;one(self &lt; 1)</td><td>true</td></tr><tr><td>Sequence{1.2, 2.3, 5.2, 0.9}-&gt;one(self &lt; 2)</td><td>false</td></tr></table><h3 id="product_.28_c2_:_Collection.28T2.29_.29_:_Set.28Tuple.28first_:_T.2C_second_:_T2.29.29">product ( c2 : Collection(T2) ) : Set(Tuple(first : T, second : T2))</h3><p>Returns a Set of Tuples which represents the cartesian product of *self* with *c2*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{3, 4}-&gt;product(Bag{3.0, 4.0})</td><td>Set{Tuple{3, 3.0}, Tuple{3, 4.0}, Tuple{4, 3.0}, Tuple{4, 4.0}}</td></tr><tr><td>Set{3, 4}-&gt;product(OrderedSet{3.0, 4.0})</td><td>Set{Tuple{3, 3.0}, Tuple{3, 4.0}, Tuple{4, 3.0}, Tuple{4, 4.0}}</td></tr></table><h3 id="reject_.28_expr_:_OclExpression_.29_:_Collection.28T.29">reject ( expr : OclExpression ) : Collection(T)</h3><p>Returns a collection with all elements of *self* except for those who validate the OclExpression *expr*. </p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>i &gt; 1 )</td><td>Sequence{1}</td></tr><tr><td>i &gt; 1 )</td><td>Bag{1}</td></tr><tr><td>i &gt; 1 )</td><td>OrderedSet{1}</td></tr><tr><td>i &gt; 1 )</td><td>Set{1}</td></tr></table><h3 id="select_.28_expr_:_OclExpression_.29_:_Collection.28T.29">select ( expr : OclExpression ) : Collection(T)</h3><p>Returns a collection with all elements of *self* that validate the OclExpression *expr*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>i &gt; 1)</td><td>Sequence{2, 3}</td></tr><tr><td>i &gt; 1 )</td><td>Bag{3, 2}</td></tr><tr><td>i &gt; 1 )</td><td>OrderedSet{2, 3}</td></tr><tr><td>i &gt; 1 )</td><td>Set{3, 2}</td></tr></table><h3 id="size_.28.29_:_Integer_2">size () : Integer</h3><p>Returns the number of elements contained in *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5}-&gt;size()</td><td>2</td></tr><tr><td>Sequence{}-&gt;size()</td><td>0</td></tr></table><h3 id="sortedBy_.28_expr_:_OclExpression_.29_:_Sequence.28T.29">sortedBy ( expr : OclExpression ) : Sequence(T)</h3><p>Returns a sorted collection containing all elements from *self* sorted in accordance with the OclExpression *expr*.
This can be used on all kind of collections yet will always yield a Sequence-typed result except for OrderedSet which returns an OrderedSet.</p><p>For the purpose of these examples we'll assume here that we have a Class *Employee* with an attribute *age*. Our model contains two employees such as *employee1.age = 24* and *employee2.age = 27*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>self.employees-&gt;sortedBy(age)</td><td>Sequence{employee1, employee2}</td></tr></table><h3 id="sum_.28.29_:_Real">sum () : Real</h3><p>Returns the sum of all elements contained in *self* if they support the '+' operation.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{2.3, 5.2} in c-&gt;sum()</td><td>7.5</td></tr><tr><td>Sequence{2, 4} in c-&gt;sum()</td><td>6</td></tr><tr><td>Sequence{2, '4'} in c-&gt;sum()</td><td><b><i>invalid</i></b></td></tr></table><h2 id="Ocl_operations_for_type_*Sequence*">Ocl operations for type *Sequence*</h2><h3 id=".3D_.28_seq_:_Sequence.28T.29_.29_:_Boolean">= ( seq : Sequence(T) ) : Boolean</h3><p>Returns **true** if *self* contains the very same objects as *seq* in the very same order as they are in *seq*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{4, 5, 'test'} = Sequence{4, 5, 'test'}</td><td>true</td></tr><tr><td>Sequence{4, 5, 'test'} = Sequence{4, 'test', 5}</td><td>false</td></tr><tr><td>Sequence{4, 5, 'test', 5} = Sequence{4, 5, 'test'}</td><td>false</td></tr></table><h3 id=".3C.3E_.28_seq_:_Sequence.28T.29_.29_:_Boolean">&lt;&gt; ( seq : Sequence(T) ) : Boolean</h3><p>Returns **true** if *self* does not contain the same objects as *seq*, or if these objects are not in the same order as they are in *seq*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{4, 5, 'test'} = Sequence{4, 5, 'test'}</td><td>false</td></tr><tr><td>Sequence{4, 5, 'test'} = Sequence{4, 'test', 5}</td><td>true</td></tr><tr><td>Sequence{4, 5, 'test', 5} = Sequence{4, 5, 'test'}</td><td>true</td></tr></table><h3 id="append_.28_object_:_T_.29_:_Sequence.28T.29">append ( object : T ) : Sequence(T)</h3><p>Returns a Sequence containing all elements of *self* followed by *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b'}-&gt;append('c')</td><td>Sequence{'a', 'b', 'c'}</td></tr></table><h3 id="at_.28_index_:_Integer_.29_:_T">at ( index : Integer ) : T</h3><p>Returns the element of *self* at the *index* position.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b'}-&gt;at(1)</td><td>a</td></tr></table><h3 id="first_.28.29_:_T">first () : T</h3><p>Returns the first element of *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{1, 2.0, '3'}-&gt;first()</td><td>1</td></tr></table><h3 id="indexOf_.28_object_:_T_.29_:_Integer">indexOf ( object : T ) : Integer</h3><p>Returns the position of *object* in sequence *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b'}-&gt;indexOf('a')</td><td>1</td></tr></table><h3 id="insertAt_.28_index_:_Integer.2C_object_:_T.29_:_Sequence.28T.29">insertAt ( index : Integer, object : T) : Sequence(T)</h3><p>Returns a Sequence containing *self* with *object* inserted at the *index* position.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b'}-&gt;insertAt(0, 'c')</td><td><b><i>invalid</i></b></td></tr><tr><td>Sequence{'a', 'b'}-&gt;insertAt(1, 'c')</td><td>Sequence{'c', 'a', 'b'}</td></tr><tr><td>Sequence{'a', 'b'}-&gt;insertAt(3, 'c')</td><td>Sequence{'a', 'b', 'c'}</td></tr><tr><td>Sequence{'a', 'b'}-&gt;insertAt(4, 'c')</td><td><b><i>invalid</i></b></td></tr></table><h3 id="last_.28.29_:_T">last () : T</h3><p>Returns the last element of *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{1, 2.0, '3'}-&gt;last()</td><td>'3'</td></tr></table><h3 id="prepend_.28_object_:_T_.29_:_Sequence.28T.29">prepend ( object : T ) : Sequence(T)</h3><p>Returns a Sequence containing *object* followed by all elements of *self* .</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b'}-&gt;prepend('c')</td><td>Sequence{'c', 'a', 'b'}</td></tr></table><h3 id="subSequence_.28_startIndex_:_Integer.2C_endIndex_:_Integer_.29_:_Sequence.28T.29">subSequence ( startIndex : Integer, endIndex : Integer ) : Sequence(T)</h3><p>Returns a Sequence containing all elements of *self* between the positions 'startIndex' and 'endIndex'. </p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b', 'c', 'd'}-&gt;subSequence(2, 3)</td><td>Sequence{'b', 'c'}</td></tr><tr><td>Sequence{'a', 'b', 'c', 'd'}-&gt;subSequence(4, 4)</td><td>Sequence{'d'}</td></tr></table><h3 id="union_.28_seq_:_Sequence.28T.29_.29_:_Sequence.28T.29">union ( seq : Sequence(T) ) : Sequence(T)</h3><p>Returns a Sequence containing all elements of *self* followed by all elements of *seq*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Sequence{'a', 'b', 'a'}-&gt;union(Sequence{'b', 'c'})</td><td>Sequence{'a', 'b', 'a', 'b', 'c'}</td></tr></table><h2 id="Ocl_operations_for_type_*Bag*">Ocl operations for type *Bag*</h2><h3 id=".3D_.28_bag_:_Bag.28T.29_.29_:_Boolean">= ( bag : Bag(T) ) : Boolean</h3><p>Returns **true** if *self* contains the same objects as *bag* in the same quantities.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Bag{4, 5, 'test', 4} = Bag{4, 'test', 5, 4}</td><td>true</td></tr><tr><td>Bag{4, 5, 'test'} = Bag{4, 'test', 5}</td><td>true</td></tr><tr><td>Bag{4, 5, 'test', 5} = Bag{4, 5, 'test'}</td><td>false</td></tr></table><h3 id=".3C.3E_.28_bag_:_Bag.28T.29_.29_:_Boolean">&lt;&gt; ( bag : Bag(T) ) : Boolean</h3><p>Returns **true** if *self* does not contain the same objects as *bag* in the same quantities.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Bag{4, 5, 'test'} = Bag{4, 5, 'test'}</td><td>false</td></tr><tr><td>Bag{4, 5, 'test'} = Bag{4, 'test', 5}</td><td>false</td></tr><tr><td>Bag{4, 5, 'test', 5} = Bag{4, 5, 'test'}</td><td>true</td></tr></table><h3 id="intersection_.28_bag_:_Bag.28T.29_.29_:_Bag.28T.29">intersection ( bag : Bag(T) ) : Bag(T)</h3><p>Returns a Bag containing all elements of *self* that are also contained by *bag*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Bag{'a', 'b', 'a'}-&gt;intersection(Bag{'a', 'b'})</td><td>Bag{'a', 'b'}</td></tr><tr><td>Bag{'a', 'b', 'a', 'b'}-&gt;intersection(Bag{'a', 'b', 'b'})</td><td>Bag{'b', 'a', 'b'}</td></tr></table><h3 id="intersection_.28_set_:_Set.28T.29_.29_:_Set.28T.29">intersection ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* that are also contained by *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Bag{'a', 'b', 'a'}-&gt;intersection(Set{'a', 'b', 'c'})</td><td>Set{'a', 'b'}</td></tr></table><h3 id="union_.28_bag_:_Bag.28T.29_.29_:_Bag.28T.29">union ( bag : Bag(T) ) : Bag(T)</h3><p>Returns a Bag containing all elements of *self* and all elements of *bag*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Bag{'a', 'b', 'a'}-&gt;union(Bag{'b', 'c'})</td><td>Bag{'b', 'a', 'b', 'a', 'c'}</td></tr></table><h3 id="union_.28_set_:_Set.28T.29_.29_:_Bag.28T.29">union ( set : Set(T) ) : Bag(T)</h3><p>Returns a Bag containing all elements of *self* and all elements of *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Bag{'a', 'b', 'a'}-&gt;union(Set{'b', 'c'})</td><td>Bag{'b', 'c', 'a', 'b', 'a'}</td></tr></table><h2 id="Ocl_operations_for_type_*OrderedSet*">Ocl operations for type *OrderedSet*</h2><h3 id=".3D_.28_set_:_Set.28T.29_.29_:_Boolean">= ( set : Set(T) ) : Boolean</h3><p>Returns **true** if *self* contains the same objects as *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{3, 5, 4} = Set{3, 5, 4}</td><td>true</td></tr><tr><td>OrderedSet{3, 5, 4} = Set{4, 3, 5, 4, 4}</td><td>true</td></tr><tr><td>OrderedSet{3, 5, 4} = Set{2, 5 ,4, 4}</td><td>false</td></tr></table><h3 id=".3D_.28_orderedset_:_OrderedSet.28T.29_.29_:_Boolean">= ( orderedset : OrderedSet(T) ) : Boolean</h3><p>Returns **true** if *self* contains the same objects as *orderedset* regardless of element ordering.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{3, 5, 4} = OrderedSet{3, 5, 4}</td><td>true</td></tr><tr><td>OrderedSet{4, 5, 'test', 5} = OrderedSet{4, 5, 'test'}</td><td>true</td></tr><tr><td>OrderedSet{4, 5, 'test'} = OrderedSet{4, 'test', 5}</td><td>true</td></tr><tr><td>OrderedSet{4, 5, 'test'} = OrderedSet{4, 'test'}</td><td>false</td></tr></table><h3 id=".3C.3E_.28_set_:_Set.28T.29_.29_:_Boolean">&lt;&gt; ( set : Set(T) ) : Boolean</h3><p>Returns **true** if *self* does not contain the same objects as *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{4, 5, 'test', 4} &lt;&gt; Set{4, 5, 'test'}</td><td>false</td></tr><tr><td>OrderedSet{4, 5, 'test', 4} &lt;&gt; Set{4, 'test', 5, 4}</td><td>false</td></tr><tr><td>OrderedSet{4, 5, 'test', 4} &lt;&gt; Set{4, 5, 'test', 2}</td><td>true</td></tr></table><h3 id=".3C.3E_.28_orderedset_:_OrderedSet.28T.29_.29_:_Boolean">&lt;&gt; ( orderedset : OrderedSet(T) ) : Boolean</h3><p>Returns **true** if *self* does not contain the same objects as *orderedset*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{4, 5, 'test', 4} &lt;&gt; OrderedSet{4, 5, 'test')</td><td>false</td></tr><tr><td>OrderedSet{4, 5, 'test', 4} &lt;&gt; OrderedSet{4, 'test', 5, 4}</td><td>false</td></tr><tr><td>OrderedSet{4, 5, 'test', 4} &lt;&gt; OrderedSet{4, 5, 'test', 2}</td><td>true</td></tr></table><h3 id=".60-.60_.28_set_:_Set.28T.29_.29_:_Set.28T.29">`-` ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* minus all elements of *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b', 'c'} - Set{'c', 'a'}</td><td>Set{'b'}</td></tr></table><h3 id="append_.28_object_:_T_.29_:_OrderedSet.28T.29">append ( object : T ) : OrderedSet(T)</h3><p>Returns an OrderedSet containing all elements of *self* followed by *object*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b'}-&gt;append('c')</td><td>OrderedSet{'a', 'b', 'c'}</td></tr></table><h3 id="at_.28_index_:_Integer_.29_:_T_2">at ( index : Integer ) : T</h3><p>Returns the element of *self* located at position *index* in the collection.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b'}-&gt;at(1)</td><td>'a'</td></tr></table><h3 id="first_.28.29_:_T_2">first () : T</h3><p>Returns the first element of *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{1, 2.0, '3'}-&gt;first()</td><td>1</td></tr></table><h3 id="indexOf_.28_object_:_T_.29_:_Integer_2">indexOf ( object : T ) : Integer</h3><p>Returns the position of *object* in *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b'}-&gt;indexOf('a')</td><td>1</td></tr></table><h3 id="insertAt_.28_index_:_Integer.2C_object_:_T_.29_:_OrderedSet.28T.29">insertAt ( index : Integer, object : T ) : OrderedSet(T)</h3><p>Returns an OrderedSet containing *self* with *object* inserted at the *index* position.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b'}-&gt;insertAt(1, 'c')</td><td>OrderedSet{'c', 'a', 'b'}</td></tr><tr><td>OrderedSet{'a', 'b'}-&gt;insertAt(3, 'c')</td><td>OrderedSet{'a', 'b', 'c'}</td></tr></table><h3 id="intersection_.28_bag_:_Bag.28T.29_.29_:_Set.28T.29">intersection ( bag : Bag(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* that are also contained by *bag*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b', 'a'}-&gt;intersection(Bag{'a', 'b'})</td><td>Set{'a', 'b'}</td></tr></table><h3 id="intersection_.28_set_:_Set.28T.29_.29_:_Set.28T.29_2">intersection ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* that are also contained by *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b', 'a'}-&gt;intersection(Set{'a', 'b'})</td><td>Set{'a', 'b'}</td></tr></table><h3 id="last_.28.29_:_T_2">last () : T</h3><p>Returns the last element of *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{1, 2.0, '3'}-&gt;last()</td><td>'3'</td></tr></table><h3 id="prepend_.28_object_:_T_.29_:_OrderedSet.28T.29">prepend ( object : T ) : OrderedSet(T)</h3><p>Returns an OrderedSet containing *object* followed by all elements of *self*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b'}-&gt;prepend('c')</td><td>OrderedSet{'c', 'a', 'b'}</td></tr></table><h3 id="subOrderedSet_.28_startIndex_:_Integer.2C_endIndex_:_Integer_.29_:_OrderedSet.28T.29">subOrderedSet ( startIndex : Integer, endIndex : Integer ) : OrderedSet(T)</h3><p>Returns an OrderedSet containing all elements of *self* between the positions *startIndex* and *endIndex*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b', 'c', 'd'}-&gt;subOrderedSet(2, 3)</td><td>OrderedSet{'b', 'c'}</td></tr><tr><td>OrderedSet{'a', 'b', 'c', 'd'}-&gt;subOrderedSet(4, 4)</td><td>OrderedSet{'d'}</td></tr></table><h3 id="symmetricDifference_.28_set_:_Set.28T.29_.29_:_Set.28T.29">symmetricDifference ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all of the elements of *self* and *set* that are not present in both.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'b', 'a', 'b', 'c'}-&gt;symmetricDifference(Set{'a', 'c', 'd'})</td><td>Set{'d', 'b'}</td></tr></table><h3 id="union_.28_bag_:_Bag.28T.29_.29_:_Bag.28T.29_2">union ( bag : Bag(T) ) : Bag(T)</h3><p>Returns a Bag containing all elements of *self* followed by all elements of *bag*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b', 'a'}-&gt;union(Bag{'b', 'c'})</td><td>Bag{'a', 'c', 'b', 'b'}</td></tr></table><h3 id="union_.28_set_:_Set.28T.29_.29_:_Set.28T.29">union ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* followed by all elements of *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>OrderedSet{'a', 'b', 'a'}-&gt;union(Set{'b', 'c'})</td><td>Set{'a', 'c', 'b'}</td></tr></table><h2 id="Ocl_operations_for_type_*Set*">Ocl operations for type *Set*</h2><h3 id=".3D_.28_set_:_Set.28T.29_.29_:_Boolean_2">= ( set : Set(T) ) : Boolean</h3><p>Returns **true** if *self* contains the same objects as *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{3, 5, 4} = Set{3, 5, 4}</td><td>true</td></tr><tr><td>Set{3, 5, 4} = Set{3, 4, 4, 5}</td><td>true</td></tr><tr><td>Set{3, 5, 4} = Set{2, 3, 5, 4}</td><td>false</td></tr></table><h3 id=".3C.3E_.28_set_:_Set.28T.29_.29_:_Boolean_2">&lt;&gt; ( set : Set(T) ) : Boolean</h3><p>Returns **true** if *self* does not contain the same objects as *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{4, 5, 'test', 4} &lt;&gt; Set{4, 5, 'test'}</td><td>false</td></tr><tr><td>Set{4, 5, 'test', 4} &lt;&gt; Set{5, 4, 'test', 4}</td><td>false</td></tr><tr><td>Set{4, 5, 'test', 4} &lt;&gt; Set{4, 'test', 5, 2}</td><td>true</td></tr></table><h3 id=".60-.60_.28_set_:_Set.28T.29_.29_:_Set.28T.29_2">`-` ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* minus all elements of *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{'a', 'b', 'c'} - Set{'c', 'a'}</td><td>Set{'b'}</td></tr></table><h3 id="intersection_.28_bag_:_Bag.28T.29_.29_:_Set.28T.29_2">intersection ( bag : Bag(T) ) : Set(T)</h3><p>Returns a Bag containing all elements of *self* that are also contained in *bag*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{'a', 'b', 'a'}-&gt;intersection(Bag{'a', 'b', 'c'})</td><td>Set{'a', 'b'}</td></tr></table><h3 id="intersection_.28_set_:_Set.28T.29_.29_:_Set.28T.29_3">intersection ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* that are also contained in *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{'a', 'b', 'a'}-&gt;intersection(Set{'a', 'b', 'c'})</td><td>Set{'b', 'a'}</td></tr></table><h3 id="symmetricDifference_.28_set_:_Set.28T.29_.29_:_Set.28T.29_2">symmetricDifference ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all of the elements of *self* and *set* that are not present in both.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{'b', 'a', 'b', 'c'}-&gt;symmetricDifference(Set{'a', 'c', 'd'})</td><td>Set{'b', 'd'}</td></tr></table><h3 id="union_.28_bag_:_Bag.28T.29_.29_:_Bag.28T.29_3">union ( bag : Bag(T) ) : Bag(T)</h3><p>Returns a Bag containing all elements of *self* and all elements of *bag*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{'a', 'b', 'a'}-&gt;union(Bag{'b', 'c'})</td><td>Bag{'a', 'c', 'b', 'b'}</td></tr></table><h3 id="union_.28_set_:_Set.28T.29_.29_:_Set.28T.29_2">union ( set : Set(T) ) : Set(T)</h3><p>Returns a Set containing all elements of *self* and all elements of *set*.</p><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Expression</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><td>Set{'a', 'b', 'a'}-&gt;union(Set{'b', 'c'})</td><td>Set{'a', 'c', 'b'}</td></tr></table><h2 id="Ocl_operations_for_type_*Boolean*">Ocl operations for type *Boolean*</h2><h3 id="And">And</h3><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">And</th><th style="background: #BCBCBC;" align="center">True</th><th style="background: #BCBCBC;" align="center">False</th><th style="background: #BCBCBC;" align="center">Invalid</th></tr><tr><th style="background: #BCBCBC;" align="center">True</th><td>true</td><td>false</td><td>true</td></tr><tr><th style="background: #BCBCBC;" align="center">False</th><td>false</td><td>false</td><td>false</td></tr><tr><th style="background: #BCBCBC;" align="center">Invalid</th><td>invalid</td><td>false</td><td>invalid</td></tr></table><h3 id="Implies">Implies</h3><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Implies</th><th style="background: #BCBCBC;" align="center">True</th><th style="background: #BCBCBC;" align="center">False</th><th style="background: #BCBCBC;" align="center">Invalid</th></tr><tr><th style="background: #BCBCBC;" align="center">True</th><td>true</td><td>false</td><td>invalid</td></tr><tr><th style="background: #BCBCBC;" align="center">False</th><td>true</td><td>true</td><td>true</td></tr><tr><th style="background: #BCBCBC;" align="center">Invalid</th><td>true</td><td>invalid</td><td>invalid</td></tr></table><h3 id="Or">Or</h3><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Or</th><th style="background: #BCBCBC;" align="center">True</th><th style="background: #BCBCBC;" align="center">False</th><th style="background: #BCBCBC;" align="center">Invalid</th></tr><tr><th style="background: #BCBCBC;" align="center">True</th><td>true</td><td>true</td><td>true</td></tr><tr><th style="background: #BCBCBC;" align="center">False</th><td>true</td><td>false</td><td>invalid</td></tr><tr><th style="background: #BCBCBC;" align="center">Invalid</th><td>true</td><td>invalid</td><td>invalid</td></tr></table><h3 id="Not">Not</h3><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Not</th><th style="background: #BCBCBC;" align="center">Result</th></tr><tr><th style="background: #BCBCBC;" align="center">True</th><td>false</td></tr><tr><th style="background: #BCBCBC;" align="center">False</th><td>true</td></tr><tr><th style="background: #BCBCBC;" align="center">Invalid</th><td>invalid</td></tr></table><h3 id="Xor">Xor</h3><table border="1" cellpadding="5" cellspacing="0"><tr><th style="background: #BCBCBC;" align="center">Xor</th><th style="background: #BCBCBC;" align="center">True</th><th style="background: #BCBCBC;" align="center">False</th><th style="background: #BCBCBC;" align="center">Invalid</th></tr><tr><th style="background: #BCBCBC;" align="center">True</th><td>false</td><td>true</td><td>invalid</td></tr><tr><th style="background: #BCBCBC;" align="center">False</th><td>true</td><td>false</td><td>invalid</td></tr><tr><th style="background: #BCBCBC;" align="center">Invalid</th><td>invalid</td><td>invalid</td><td>invalid</td></tr></table></body></html>