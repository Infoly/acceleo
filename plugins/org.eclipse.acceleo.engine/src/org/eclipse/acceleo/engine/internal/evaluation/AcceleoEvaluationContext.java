/*******************************************************************************
 * Copyright (c) 2008, 2009 Obeo.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Obeo - initial API and implementation
 *******************************************************************************/
package org.eclipse.acceleo.engine.internal.evaluation;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.eclipse.acceleo.engine.AcceleoEngineMessages;
import org.eclipse.acceleo.engine.AcceleoEnginePlugin;
import org.eclipse.acceleo.engine.AcceleoEvaluationException;
import org.eclipse.acceleo.engine.event.AcceleoTextGenerationEvent;
import org.eclipse.acceleo.engine.event.AcceleoTextGenerationListener;
import org.eclipse.acceleo.model.mtl.Block;
import org.eclipse.emf.ecore.EObject;

/**
 * This will hold all necessary variables for the evaluation of an Acceleo module.
 * 
 * @author <a href="mailto:laurent.goubet@obeo.fr">Laurent Goubet</a>
 */
public final class AcceleoEvaluationContext {
	/** Default size to be used for new buffers. */
	private static final int DEFAULT_BUFFER_SIZE = 1024;

	/** This pool will be used for the lost file creators. */
	private static final ExecutorService LOST_CREATORS_POOL = Executors.newFixedThreadPool(Runtime
			.getRuntime().availableProcessors());

	/** This will be populated with the list of tasks currently executing fot the creation of lost files. */
	private static final List<Future<Object>> LOST_CREATION_TASKS = new ArrayList<Future<Object>>();

	/**
	 * Blocks' init sections might change existing variables which will need to be restored afterwards. This
	 * will keep the altered variables values.
	 */
	private final LinkedList<Map<String, Object>> blockVariables = new LinkedList<Map<String, Object>>();

	/** Holds the generation preview in the form of mappings filePath => fileContent. */
	private final Map<String, StringWriter> generationPreview = new HashMap<String, StringWriter>();

	/** References the file which is to be used as the root for all generated files. */
	private final File generationRoot;

	/**
	 * This will hold the list of all listeners registered for notification on text generation from this
	 * engine.
	 */
	private final List<AcceleoTextGenerationListener> listeners = new ArrayList<AcceleoTextGenerationListener>(3);

	/** If <code>true</code>, no file will be generated by this context. */
	private final boolean previewMode;

	/** This will keep a reference to all user code blocks of a given File. */
	private final Map<Writer, Map<String, String>> userCodeBlocks = new HashMap<Writer, Map<String, String>>();

	/** This will hold the buffer stack. */
	private final LinkedList<Writer> writers = new LinkedList<Writer>();

	/**
	 * Instantiates an evaluation context given the root of the to-be-generated files.
	 * 
	 * @param root
	 *            Root of all files that will be generated.
	 * @param listeners
	 *            The list of all listeners that are to be notified for text generation from this context.
	 * @param preview
	 *            Tells this evaluation context it shouldn't generate any file.
	 */
	public AcceleoEvaluationContext(File root, List<AcceleoTextGenerationListener> listeners, boolean preview) {
		generationRoot = root;
		previewMode = preview;
		this.listeners.addAll(listeners);
		flatten();
	}

	/**
	 * Allows clients to await for the lost file creation to end.
	 * 
	 * @throws InterruptedException
	 *             This will be thrown if the lost files creation is interrupted somehow.
	 */
	public static void awaitCompletion() throws InterruptedException {
		for (Future<Object> task : new ArrayList<Future<Object>>(LOST_CREATION_TASKS)) {
			while (!task.isDone() && !task.isCancelled()) {
				try {
					task.get();
				} catch (ExecutionException e) {
					// LostFileWriters cannot throw exceptions
				}
			}
			LOST_CREATION_TASKS.remove(task);
		}
	}

	/**
	 * Appends the given string to the last buffer of the context stack. This will notify all text generation
	 * listeners along the way.
	 * 
	 * @param string
	 *            String that is to be appended to the current buffer.
	 * @param sourceBlock
	 *            The block for which this text has been generated.
	 * @param source
	 *            The Object for which was generated this text.
	 * @throws AcceleoEvaluationException
	 *             Thrown if we cannot append to the current buffer.
	 */
	public void append(String string, Block sourceBlock, EObject source) throws AcceleoEvaluationException {
		try {
			final Writer currentWriter = writers.getLast();
			currentWriter.append(string);
			fireTextGenerated(new AcceleoTextGenerationEvent(string, sourceBlock, source));
		} catch (final IOException e) {
			throw new AcceleoEvaluationException(AcceleoEngineMessages
					.getString("AcceleoEvaluationContext.AppendException"), e); //$NON-NLS-1$
		}
	}

	/**
	 * Closes the last writer of the stack and returns its result if it was a StringWriter. The empty String
	 * will be returned for FileWriters.
	 * 
	 * @return Result held by the last writer of the stack.
	 * @throws AcceleoEvaluationException
	 *             This will be thrown if the last writer of the stack cannot be flushed and closed.
	 */
	public String closeContext() throws AcceleoEvaluationException {
		final Writer last = writers.removeLast();
		final String result;
		try {
			if (last instanceof AcceleoFileWriter) {
				// Did we lose user code?
				final Map<String, String> lostCode = userCodeBlocks.remove(last);
				if (lostCode.size() > 0) {
					createLostFile(((AcceleoFileWriter)last).getTargetPath(), lostCode);
				}
				// Add a carriage return at the end of each file so that no problem will arise with
				// indentation when appending
				last.append('\n');
				last.close();
				result = ""; //$NON-NLS-1$
			} else if (last instanceof OutputStreamWriter) {
				last.close();
				result = ""; //$NON-NLS-1$
			} else if (previewMode) {
				for (final Entry<String, StringWriter> entry : generationPreview.entrySet()) {
					if (entry.getValue() == last) {
						final Map<String, String> lostCode = userCodeBlocks.remove(last);
						if (lostCode.size() > 0) {
							StringWriter lostContent = new StringWriter();
							for (final String lostAreaContent : lostCode.values()) {
								lostContent.append(lostAreaContent);
								lostContent.append('\n');
							}
							generationPreview.put(entry.getKey().concat(".lost"), lostContent); //$NON-NLS-1$
						}
					}
				}
				result = last.toString();
			} else {
				// others are plain StringWriters. Close has no effect on those.
				result = last.toString();
			}
			return result;
		} catch (final IOException e) {
			throw new AcceleoEvaluationException(AcceleoEngineMessages.getString("AcceleoEvaluationContext.WriteError"), //$NON-NLS-1$
					e);
		}
	}

	/**
	 * This will be used to dispose of all created buffers and caches.
	 * 
	 * @throws AcceleoEvaluationException
	 *             Thrown if the disposal of the old writers fails.
	 */
	public void dispose() throws AcceleoEvaluationException {
		AcceleoEvaluationException exception = null;
		try {
			try {
				for (final Writer writer : writers) {
					writer.close();
				}
			} catch (final IOException e) {
				exception = new AcceleoEvaluationException(AcceleoEngineMessages
						.getString("AcceleoEvaluationContext.CleanUpError"), e); //$NON-NLS-1$
			}
			try {
				awaitCompletion();
			} catch (InterruptedException e) {
				exception = new AcceleoEvaluationException(AcceleoEngineMessages
						.getString("AcceleoEvaluationContext.CleanUpError"), e); //$NON-NLS-1$
			}
		} finally {
			writers.clear();
			blockVariables.clear();
			userCodeBlocks.clear();
			listeners.clear();
			generationPreview.clear();
			LOST_CREATION_TASKS.clear();
		}
		if (exception != null) {
			throw exception;
		}
	}

	/**
	 * Returns the preview of the generation handled by this context.
	 * 
	 * @return The generation preview.
	 */
	public Map<String, StringWriter> getGenerationPreview() {
		return generationPreview;
	}

	/**
	 * This will return the last variables that were added to the stack so that they can be restored in the
	 * evaluation environment. Note that calling this method removes the returned variables from the stack.
	 * 
	 * @return The variables that were last saved.
	 */
	public Map<String, Object> getLastVariablesValues() {
		return blockVariables.removeLast();
	}

	/**
	 * This will return the content of the protected area associated with the given marker in the current
	 * context.
	 * 
	 * @param marker
	 *            Marker of the sought protected area content.
	 * @return Content of the protected area associated with the given marker. <code>null</code> if no content
	 *         can be found.
	 */
	public String getProtectedAreaContent(String marker) {
		// Seeks out the last opened file writer
		Writer writer = null;
		for (int i = writers.size() - 1; i >= 0; i--) {
			writer = writers.get(i);
			if (writer instanceof AcceleoFileWriter) {
				break;
			}
			writer = null;
		}

		final Map<String, String> areas = userCodeBlocks.get(writer);
		if (areas != null) {
			return areas.remove(marker);
		}
		return null;
	}

	/**
	 * Creates a new writer and appends it to the end of the stack.
	 * 
	 * @throws AcceleoEvaluationException
	 *             Thrown if the precedent buffer cannot be flushed.
	 */
	public void openNested() throws AcceleoEvaluationException {
		try {
			if (writers.size() > 0) {
				writers.getLast().flush();
			}
		} catch (final IOException e) {
			throw new AcceleoEvaluationException(AcceleoEngineMessages.getString("AcceleoEvaluationContext.FlushError"), //$NON-NLS-1$
					e);
		}
		writers.add(new StringWriter(DEFAULT_BUFFER_SIZE));
	}

	/**
	 * Create a new writer directed at the given {@link OutputStream}. This is mainly used for fileBlocks with
	 * "stdout" URI.
	 * 
	 * @param stream
	 *            Stream to which writing will be directed.
	 */
	public void openNested(OutputStream stream) {
		try {
			if (writers.size() > 0) {
				writers.getLast().flush();
			}
		} catch (final IOException e) {
			throw new AcceleoEvaluationException(AcceleoEngineMessages.getString("AcceleoEvaluationContext.FlushError"), //$NON-NLS-1$
					e);
		}
		writers.add(new OutputStreamWriter(new AcceleoFilterOutputStream(stream)));
	}

	/**
	 * Create a new writer for the file located at the given path under <tt>generationRoot</tt> and appends it
	 * to the end of the stack.
	 * <p>
	 * &quot;file&quot; schemes are handled as absolute paths and will ignore the <tt>generationRoot</tt>.
	 * </p>
	 * 
	 * @param filePath
	 *            Path of the file around which we need a FileWriter. The file will be created under the
	 *            generationRoot if needed.
	 * @param fileBlock
	 *            The file block which asked for this context. Only used for generation events.
	 * @param source
	 *            The source EObject for this file block. Only used for generation events.
	 * @param appendMode
	 *            If <code>false</code>, the file will be replaced by a new one.
	 * @throws AcceleoEvaluationException
	 *             Thrown if the file cannot be created.
	 */
	public void openNested(String filePath, Block fileBlock, EObject source, boolean appendMode)
			throws AcceleoEvaluationException {
		final File generatedFile;
		if (filePath.startsWith("file:")) { //$NON-NLS-1$
			generatedFile = new File(filePath);
		} else {
			generatedFile = new File(generationRoot, filePath);
		}
		fireFilePathComputed(new AcceleoTextGenerationEvent(generatedFile.getPath(), fileBlock, source));
		if (!previewMode && !generatedFile.getParentFile().exists()) {
			if (!generatedFile.getParentFile().mkdirs()) {
				throw new AcceleoEvaluationException(AcceleoEngineMessages.getString(
						"AcceleoEvaluationContext.FolderCreationError", generatedFile.getParentFile())); //$NON-NLS-1$
			}
		}
		try {
			writers.getLast().flush();
			Map<String, String> savedCodeBlocks = new HashMap<String, String>();
			if (generatedFile.exists()) {
				savedCodeBlocks = saveProtectedAreas(generatedFile);
			}
			final Writer writer;
			if (!previewMode) {
				writer = new AcceleoFileWriter(generatedFile, appendMode);
			} else {
				writer = new StringWriter();
				generationPreview.put(generatedFile.getPath(), (StringWriter)writer);
			}
			userCodeBlocks.put(writer, savedCodeBlocks);
			writers.add(writer);
		} catch (final IOException e) {
			throw new AcceleoEvaluationException(AcceleoEngineMessages.getString(
					"AcceleoEvaluationContext.FileCreationError", generatedFile.getPath()), e); //$NON-NLS-1$
		}
	}

	/**
	 * This will save the given variables in the stack.
	 * 
	 * @param vars
	 *            Variables which values will need to be restored after evaluation.
	 */
	public void saveVariableValues(Map<String, Object> vars) {
		blockVariables.add(vars);
	}

	/**
	 * Creates a .lost file that will contain the lost user code from file located at
	 * <code>originalPath</code>. As it doesn't need any more computation, the lost file creation will take
	 * place in a separate process.
	 * 
	 * @param originalPath
	 *            Absolute path of the file which user code has been fully or partially lost.
	 * @param lostAreas
	 *            Protected areas which markers couldn't be matched with markers from the template file.
	 */
	private void createLostFile(final String originalPath, final Map<String, String> lostAreas) {
		final Callable<Object> fileCreator = new LostFileWriter(originalPath, lostAreas);
		LOST_CREATION_TASKS.add(LOST_CREATORS_POOL.submit(fileCreator));
	}

	/**
	 * Used internally to remove ended tasks from the cache.
	 */
	private void flatten() {
		for (Future<Object> task : new ArrayList<Future<Object>>(LOST_CREATION_TASKS)) {
			if (task.isDone() && task.isCancelled()) {
				LOST_CREATION_TASKS.remove(task);
			}
		}
	}

	/**
	 * Notifies all listeners that a file is going to be created.
	 * 
	 * @param event
	 *            The generation event that is to be sent to registered listeners.
	 */
	private void fireFilePathComputed(AcceleoTextGenerationEvent event) {
		for (AcceleoTextGenerationListener listener : listeners) {
			listener.filePathComputed(event);
		}
	}

	/**
	 * Notifies all listeners that text has been generated.
	 * 
	 * @param event
	 *            The generation event that is to be sent to registered listeners.
	 */
	private void fireTextGenerated(AcceleoTextGenerationEvent event) {
		for (AcceleoTextGenerationListener listener : listeners) {
			listener.textGenerated(event);
		}
	}

	/**
	 * This will return the list of protected areas the given file contains.
	 * 
	 * @param file
	 *            File which protected areas are to be saved.
	 * @return The list of saved protected areas.
	 * @throws IOException
	 *             Thrown if we cannot read through <tt>file</tt>.
	 */
	private Map<String, String> saveProtectedAreas(File file) throws IOException {
		final Map<String, String> protectedAreas = new HashMap<String, String>();
		BufferedReader reader = null;
		try {
			final String usercodeStart = AcceleoEngineMessages.getString("usercode.start"); //$NON-NLS-1$
			final String usercodeEnd = AcceleoEngineMessages.getString("usercode.end"); //$NON-NLS-1$

			reader = new BufferedReader(new FileReader(file));
			String line = reader.readLine();
			while (line != null) {
				if (line.contains(usercodeStart)) {
					final String marker = line
							.substring(line.indexOf(usercodeStart) + usercodeStart.length()).trim();
					final StringBuffer areaContent = new StringBuffer('\n');
					// Everything preceding the start of user code doesn't need to be saved
					areaContent.append(line.substring(line.indexOf(usercodeStart)));
					line = reader.readLine();
					while (line != null) {
						areaContent.append('\n');
						// Everything following the end of use code marker doesn't need to be saved
						if (line.contains(usercodeEnd)) {
							areaContent.append(line.substring(0, line.indexOf(usercodeEnd)
									+ usercodeEnd.length()));
							break;
						}
						areaContent.append(line);
						line = reader.readLine();
					}
					areaContent.append('\n');
					protectedAreas.put(marker, areaContent.toString());
				}
				line = reader.readLine();
			}
		} catch (final FileNotFoundException e) {
			// cannot be thrown here, we were called after testing that the file indeed existed.
		} finally {
			if (reader != null) {
				reader.close();
			}
		}
		return protectedAreas;
	}

	/**
	 * This will be used to create log files.
	 * 
	 * @author <a href="mailto:laurent.goubet@obeo.fr">Laurent Goubet</a>
	 */
	private final class LostFileWriter implements Callable<Object> {
		/** Lost protected areas. */
		private final Map<String, String> lostAreas;

		/** Path to the file which protected areas have been lost. */
		private final String originalPath;

		/**
		 * Instantiate a writer given the path to the original file (will be suffixed by &quot;.lost&quot;)
		 * and a map containing the lost protected areas.
		 * 
		 * @param originalPath
		 *            Path to the file in which protected areas have been lost.
		 * @param lostAreas
		 *            Map containing the lost protected areas of this file.
		 */
		LostFileWriter(String originalPath, Map<String, String> lostAreas) {
			this.originalPath = originalPath;
			this.lostAreas = lostAreas;
		}

		/**
		 * {@inheritDoc}
		 * 
		 * @see java.lang.Runnable#run()
		 */
		public Object call() {
			StringBuilder lostContent = new StringBuilder();
			for (final String lostAreaContent : lostAreas.values()) {
				lostContent.append(lostAreaContent);
				lostContent.append('\n');
			}
			Writer writer = null;
			try {
				final File lostFile = new File(originalPath.concat(".lost")); //$NON-NLS-1$
				writer = new BufferedWriter(new FileWriter(lostFile, true));
				writer.append('\n').append(Calendar.getInstance().getTime().toString()).append('\n');
				writer
						.append("================================================================================"); //$NON-NLS-1$
				writer.append('\n');
				writer.append(lostContent);
			} catch (final IOException e) {
				final String errorMessage = AcceleoEngineMessages.getString(
						"AcceleoEvaluationContext.LostContent", originalPath, lostContent); //$NON-NLS-1$
				AcceleoEnginePlugin.log(errorMessage, false);
			} finally {
				if (writer != null) {
					try {
						writer.close();
					} catch (IOException e) {
						AcceleoEnginePlugin.log(e, false);
					}
				}
			}
			// This has no explicit result. Only used to await termination
			return null;
		}
	}

	/**
	 * This implementation of a BufferedWriter will be wrapped around a FileWriter and keep a reference to its
	 * target file's absolute path.
	 * 
	 * @author <a href="mailto:laurent.goubet@obeo.fr">Laurent Goubet</a>
	 */
	private final class AcceleoFileWriter extends BufferedWriter {
		/** Keeps a reference to the target file's absolute path. */
		private final String targetPath;

		/**
		 * Constructs a buffered file writer around the given file.
		 * 
		 * @param target
		 *            File in which this writer will append text.
		 * @param appendMode
		 *            Tells us wether the former content of the file should be deleted.
		 * @throws IOException
		 *             Thrown if the target file doesn't exist and cannot be created.
		 */
		public AcceleoFileWriter(File target, boolean appendMode) throws IOException {
			super(new FileWriter(target, appendMode));
			targetPath = target.getAbsolutePath();
		}

		public String getTargetPath() {
			return targetPath;
		}
	}

	/**
	 * This implementation of a FilterOutputStream will avoid closing the standard output if it is the
	 * underlying stream.
	 * 
	 * @author <a href="mailto:laurent.goubet@obeo.fr">Laurent Goubet</a>
	 */
	private final class AcceleoFilterOutputStream extends FilterOutputStream {
		/**
		 * Constructs an output stream redirecting all calls to the given {@link OutputStream}.
		 * 
		 * @param out
		 *            The decorated output stream.
		 */
		public AcceleoFilterOutputStream(OutputStream out) {
			super(out);
		}

		/**
		 * {@inheritDoc}
		 * 
		 * @see java.io.FilterOutputStream#close()
		 */
		@Override
		public void close() throws IOException {
			try {
				flush();
			} catch (IOException e) {
				// Ignored exception
			}
			if (out != System.out) {
				out.close();
			}
		}
	}
}
